{"version":3,"sources":["index.js","cjs/index.js","cjs/detector.js","cjs/buffer.js","cjs/collection.js","cjs/copier.js","cjs/copy_map.js","cjs/global.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,ACHA,AHSA,ADGA;AELA,ACHA,ACHA,AHSA,ADGA;AELA,ACHA,ACHA,AHSA,ADGA;AELA,ACHA,ACHA,ACHA,AJYA,ADGA;AELA,ACHA,ACHA,ACHA,AJYA,ADGA;AELA,ACHA,ACHA,ACHA,AJYA,ADGA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA;AELA,ACHA,ACHA,ACHA,AJYA,ADGA;AELA,ACHA,ACHA,ACHA,AJYA,ADGA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,ACHA,ACHA,ALeA;AELA,ACHA,AENA,ALeA;AELA,ACHA,AENA,ALeA;AELA,ACHA,AENA,ALeA;AELA,ACHA,AENA,ALeA;AELA,ACHA,AENA,ALeA;AELA,ACHA,AENA,ALeA;AELA,ACHA,AENA,ALeA;AELA,ACHA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./cjs/index.js').default;\n","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = deepcopy;\n\nvar _detector = require(\"./detector.js\");\n\nvar _collection = require(\"./collection.js\");\n\nvar _copier = require(\"./copier.js\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * deepcopy function\n *\n * @param {*} value\n * @param {Object|Function} [options]\n * @return {*}\n */\nfunction deepcopy(value, options = {}) {\n  if (typeof options === 'function') {\n    options = {\n      customizer: options\n    };\n  }\n\n  const _options = options,\n        customizer = _options.customizer;\n  const valueType = (0, _detector.detectType)(value);\n\n  if (!(0, _collection.isCollection)(valueType)) {\n    return recursiveCopy(value, null, null, null, customizer);\n  }\n\n  const copiedValue = (0, _copier.copy)(value, valueType, customizer);\n  const references = new WeakMap([[value, copiedValue]]);\n  const visited = new WeakSet([value]);\n  return recursiveCopy(value, copiedValue, references, visited, customizer);\n}\n/**\n * recursively copy\n *\n * @param {*} value target value\n * @param {*} clone clone of value\n * @param {WeakMap} references visited references of clone\n * @param {WeakSet} visited visited references of value\n * @param {Function} customizer user customize function\n * @return {*}\n */\n\n\nfunction recursiveCopy(value, clone, references, visited, customizer) {\n  const type = (0, _detector.detectType)(value);\n  const copiedValue = (0, _copier.copy)(value, type); // return if not a collection value\n\n  if (!(0, _collection.isCollection)(type)) {\n    return copiedValue;\n  }\n\n  let keys;\n\n  switch (type) {\n    case 'Arguments':\n    case 'Array':\n      keys = Object.keys(value);\n      break;\n\n    case 'Object':\n      keys = Object.keys(value);\n      keys.push(...Object.getOwnPropertySymbols(value));\n      break;\n\n    case 'Map':\n    case 'Set':\n      keys = value.keys();\n      break;\n\n    default:\n  } // walk within collection with iterator\n\n\n  var _iterator = _createForOfIteratorHelper(keys),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      let collectionKey = _step.value;\n      const collectionValue = (0, _collection.get)(value, collectionKey, type);\n\n      if (visited.has(collectionValue)) {\n        // for [Circular]\n        (0, _collection.set)(clone, collectionKey, references.get(collectionValue), type);\n      } else {\n        const collectionValueType = (0, _detector.detectType)(collectionValue);\n        const copiedCollectionValue = (0, _copier.copy)(collectionValue, collectionValueType); // save reference if value is collection\n\n        if ((0, _collection.isCollection)(collectionValueType)) {\n          references.set(collectionValue, copiedCollectionValue);\n          visited.add(collectionValue);\n        }\n\n        (0, _collection.set)(clone, collectionKey, recursiveCopy(collectionValue, copiedCollectionValue, references, visited, customizer), type);\n      }\n    } // TODO: isSealed/isFrozen/isExtensible\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return clone;\n}\n//# sourceMappingURL=index.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.detectType = detectType;\n\nvar _typeDetect = _interopRequireDefault(require(\"type-detect\"));\n\nvar _buffer = require(\"./buffer.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * detect type of value\n *\n * @param {*} value\n * @return {string}\n */\nfunction detectType(value) {\n  // NOTE: isBuffer must execute before type-detect,\n  // because type-detect returns 'Uint8Array'.\n  if ((0, _buffer.isBuffer)(value)) {\n    return 'Buffer';\n  }\n\n  return (0, _typeDetect.default)(value);\n}\n//# sourceMappingURL=detector.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.copy = exports.isBuffer = void 0;\nconst isBufferExists = typeof Buffer !== 'undefined';\nconst isBufferFromExists = isBufferExists && typeof Buffer.from !== 'undefined';\nconst isBuffer = isBufferExists ?\n/**\n * is value is Buffer?\n *\n * @param {*} value\n * @return {boolean}\n */\nfunction isBuffer(value) {\n  return Buffer.isBuffer(value);\n} :\n/**\n * return false\n *\n * NOTE: for Buffer unsupported\n *\n * @return {boolean}\n */\nfunction isBuffer() {\n  return false;\n};\nexports.isBuffer = isBuffer;\nconst copy = isBufferFromExists ?\n/**\n * copy Buffer\n *\n * @param {Buffer} value\n * @return {Buffer}\n */\nfunction copy(value) {\n  return Buffer.from(value);\n} : isBufferExists ?\n/**\n * copy Buffer\n *\n * NOTE: for old node.js\n *\n * @param {Buffer} value\n * @return {Buffer}\n */\nfunction copy(value) {\n  return new Buffer(value);\n} :\n/**\n * shallow copy\n *\n * NOTE: for Buffer unsupported\n *\n * @param {*}\n * @return {*}\n */\nfunction copy(value) {\n  return value;\n};\nexports.copy = copy;\n//# sourceMappingURL=buffer.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.get = get;\nexports.isCollection = isCollection;\nexports.set = set;\n\nvar _detector = require(\"./detector.js\");\n\n/**\n * collection types\n */\nconst collectionTypeSet = new Set(['Arguments', 'Array', 'Map', 'Object', 'Set']);\n/**\n * get value from collection\n *\n * @param {Array|Object|Map|Set} collection\n * @param {string|number|symbol} key\n * @param {string} [type=null]\n * @return {*}\n */\n\nfunction get(collection, key, type = null) {\n  const valueType = type || (0, _detector.detectType)(collection);\n\n  switch (valueType) {\n    case 'Arguments':\n    case 'Array':\n    case 'Object':\n      return collection[key];\n\n    case 'Map':\n      return collection.get(key);\n\n    case 'Set':\n      // NOTE: Set.prototype.keys is alias of Set.prototype.values\n      // it means key is equals value\n      return key;\n\n    default:\n  }\n}\n/**\n * check to type string is collection\n *\n * @param {string} type\n */\n\n\nfunction isCollection(type) {\n  return collectionTypeSet.has(type);\n}\n/**\n * set value to collection\n *\n * @param {Array|Object|Map|Set} collection\n * @param {string|number|symbol} key\n * @param {*} value\n * @param {string} [type=null]\n * @return {Array|Object|Map|Set}\n */\n\n\nfunction set(collection, key, value, type = null) {\n  const valueType = type || (0, _detector.detectType)(collection);\n\n  switch (valueType) {\n    case 'Arguments':\n    case 'Array':\n    case 'Object':\n      collection[key] = value;\n      break;\n\n    case 'Map':\n      collection.set(key, value);\n      break;\n\n    case 'Set':\n      collection.add(value);\n      break;\n\n    default:\n  }\n\n  return collection;\n}\n//# sourceMappingURL=collection.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.copy = copy;\n\nvar _copy_map = _interopRequireDefault(require(\"./copy_map.js\"));\n\nvar _detector = require(\"./detector.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * no operation\n */\nfunction noop() {}\n/**\n * copy value\n *\n * @param {*} value\n * @param {string} [type=null]\n * @param {Function} [customizer=noop]\n * @return {*}\n */\n\n\nfunction copy(value, type = null, customizer = noop) {\n  if (arguments.length === 2 && typeof type === 'function') {\n    customizer = type;\n    type = null;\n  }\n\n  const valueType = type || (0, _detector.detectType)(value);\n\n  const copyFunction = _copy_map.default.get(valueType);\n\n  if (valueType === 'Object') {\n    const result = customizer(value, valueType);\n\n    if (result !== undefined) {\n      return result;\n    }\n  } // NOTE: TypedArray needs pass type to argument\n\n\n  return copyFunction ? copyFunction(value, valueType) : value;\n}\n//# sourceMappingURL=copier.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer.js\");\n\nvar _global = require(\"./global.js\");\n\n/**\n * copy ArrayBuffer\n *\n * @param {ArrayBuffer} value\n * @return {ArrayBuffer}\n */\nfunction copyArrayBuffer(value) {\n  return value.slice(0);\n}\n/**\n * copy Boolean\n *\n * @param {Boolean} value\n * @return {Boolean}\n */\n\n\nfunction copyBoolean(value) {\n  return new Boolean(value.valueOf());\n}\n/**\n * copy DataView\n *\n * @param {DataView} value\n * @return {DataView}\n */\n\n\nfunction copyDataView(value) {\n  // TODO: copy ArrayBuffer?\n  return new DataView(value.buffer);\n}\n/**\n * copy Buffer\n *\n * @param {Buffer} value\n * @return {Buffer}\n */\n\n\nfunction copyBuffer(value) {\n  return (0, _buffer.copy)(value);\n}\n/**\n * copy Date\n *\n * @param {Date} value\n * @return {Date}\n */\n\n\nfunction copyDate(value) {\n  return new Date(value.getTime());\n}\n/**\n * copy Number\n *\n * @param {Number} value\n * @return {Number}\n */\n\n\nfunction copyNumber(value) {\n  return new Number(value);\n}\n/**\n * copy RegExp\n *\n * @param {RegExp} value\n * @return {RegExp}\n */\n\n\nfunction copyRegExp(value) {\n  return new RegExp(value.source, value.flags);\n}\n/**\n * copy String\n *\n * @param {String} value\n * @return {String}\n */\n\n\nfunction copyString(value) {\n  return new String(value);\n}\n/**\n * copy TypedArray\n *\n * @param {*} value\n * @return {*}\n */\n\n\nfunction copyTypedArray(value, type) {\n  const typedArray = _global.globalObject[type];\n\n  if (typedArray.from) {\n    return _global.globalObject[type].from(value);\n  }\n\n  return new _global.globalObject[type](value);\n}\n/**\n * shallow copy\n *\n * @param {*} value\n * @return {*}\n */\n\n\nfunction shallowCopy(value) {\n  return value;\n}\n/**\n * get empty Array\n *\n * @return {Array}\n */\n\n\nfunction getEmptyArray() {\n  return [];\n}\n/**\n * get empty Map\n *\n * @return {Map}\n */\n\n\nfunction getEmptyMap() {\n  return new Map();\n}\n/**\n * get empty Object\n *\n * @return {Object}\n */\n\n\nfunction getEmptyObject() {\n  return {};\n}\n/**\n * get empty Set\n *\n * @return {Set}\n */\n\n\nfunction getEmptySet() {\n  return new Set();\n}\n\nvar _default = new Map([// deep copy\n['ArrayBuffer', copyArrayBuffer], ['Boolean', copyBoolean], ['Buffer', copyBuffer], ['DataView', copyDataView], ['Date', copyDate], ['Number', copyNumber], ['RegExp', copyRegExp], ['String', copyString], // typed arrays\n// TODO: pass bound function\n['Float32Array', copyTypedArray], ['Float64Array', copyTypedArray], ['Int16Array', copyTypedArray], ['Int32Array', copyTypedArray], ['Int8Array', copyTypedArray], ['Uint16Array', copyTypedArray], ['Uint32Array', copyTypedArray], ['Uint8Array', copyTypedArray], ['Uint8ClampedArray', copyTypedArray], // shallow copy\n['Array Iterator', shallowCopy], ['Map Iterator', shallowCopy], ['Promise', shallowCopy], ['Set Iterator', shallowCopy], ['String Iterator', shallowCopy], ['function', shallowCopy], ['global', shallowCopy], // NOTE: WeakMap and WeakSet cannot get entries\n['WeakMap', shallowCopy], ['WeakSet', shallowCopy], // primitives\n['boolean', shallowCopy], ['null', shallowCopy], ['number', shallowCopy], ['string', shallowCopy], ['symbol', shallowCopy], ['undefined', shallowCopy], // collections\n// NOTE: return empty value, because recursively copy later.\n['Arguments', getEmptyArray], ['Array', getEmptyArray], ['Map', getEmptyMap], ['Object', getEmptyObject], ['Set', getEmptySet] // NOTE: type-detect returns following types\n// 'Location'\n// 'Document'\n// 'MimeTypeArray'\n// 'PluginArray'\n// 'HTMLQuoteElement'\n// 'HTMLTableDataCellElement'\n// 'HTMLTableHeaderCellElement'\n// TODO: is type-detect never return 'object'?\n// 'object'\n]);\n\nexports.default = _default;\n//# sourceMappingURL=copy_map.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.globalObject = void 0;\nconst freeGlobalThis = typeof globalThis !== 'undefined' && globalThis !== null && globalThis.Object === Object && globalThis;\nconst freeGlobal = typeof global !== 'undefined' && global !== null && global.Object === Object && global;\nconst freeSelf = typeof self !== 'undefined' && self !== null && self.Object === Object && self;\nconst globalObject = freeGlobalThis || freeGlobal || freeSelf || Function('return this')();\nexports.globalObject = globalObject;\n//# sourceMappingURL=global.js.map"]}