{"version":3,"sources":["main.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Observer = factory());\n}(this, (function () { \n\n  /** 深拷贝 目前只支持基本数据类型 Object Array */\n  function deepCopy(data) {\n    // 如果data为原始类型，则直接返回\n    if (isPrimitiveValue(data)) return data\n\n    const clone = data instanceof Array ? [] : {};\n\n    for (let i in data) {\n      const item = data[i];\n      clone[i] = (item instanceof Object) ? deepCopy(item) : item;\n    }\n\n    return clone\n  }\n\n  /** 是否为基本类型 */\n  function isPrimitiveValue(value) {\n    return !(value instanceof Object)\n  }\n\n  /** 是否为有效属性 */\n  function isValidProperty(target, props) {\n    return (\n      target.hasOwnProperty(props) &&\n      Object.getOwnPropertyDescriptor(target, props).enumerable &&\n      Object.getOwnPropertyDescriptor(target, props).configurable\n    )\n  }\n\n  function nextTick(fn) {\n    // TODO: 目前使用Promise作为nextTick函数，后续还需要根据具体环境使用不同的nextTick\n    if (Promise) {\n      return Promise.resolve().then(fn)\n    } else {\n      // 如果没有Promise 则使用setTimeout （宏任务）\n      return setTimeout(fn, 0);\n    }\n  }\n\n  /** 调度器 \n   * 想要在下一次微任务中来依次执行改变的回调\n   * \n   * TODO: 后续需要使用单例模式\n  */\n  function Scheduler(originData, fn = () => {}) {\n    this.data = deepCopy(originData); // \n    this.list = []; // 在一个Tick中收集到的变更路径列表\n    this.callback = fn; // 在每一个Tick后触发\n    this.status = 0; // 0 初始化状态   1 等待状态\n\n    /**\n     * 需要修改的数据\n     * @param {*} data 数据源\n     * @param {*} pathArray 需要更新的属性的路径\n     * @param {*} value 更新的值\n     * \n     * a, [a1, a2, a3], 11   =>   a.a1.a2.a3 = 11\n     */\n    function setValue(data, pathArray, value) {\n      var _data = data;\n      for(let i = 0; i < pathArray.length - 1; i++) {\n        _data = _data[pathArray[i]];\n      }\n\n      _data[pathArray[pathArray.length - 1]] = value;\n    \n      return data\n    }\n\n    /**\n     * \n     * 对同步的数据变更进行收集，然后在一个Tick后，在调用回调进行返回收集到的所有更新\n     * data = { oldValue, newValue, path }\n     */\n    Scheduler.prototype.collect  = function collect(data) {\n      // 如果是初始化状态，需要执行一个Promise\n      if (this.status === 0) {\n        nextTick(() => {\n          let newValue = deepCopy(this.data);\n          const rootProps = []; // 改动属性的根属性\n\n          this.list.forEach(item => {\n            rootProps.push(item.path[0]);\n            newValue = setValue(newValue, item.path, item.newValue);\n          });\n\n          this.callback({\n            newValue,\n            oldValue: this.data,\n            paths: Array.from(new Set(rootProps)) // 属性列表进行去重\n          });\n\n          this.list = []; // 清空队列\n          this.data = newValue; // 将原始数据更新成最新的数据\n          this.status = 0; // 执行完成则将状态恢复成初始状态\n        });\n\n        this.status = 1; // 等待中\n      }\n\n      this.list.push(data);\n    };\n  }\n\n  const globalKey = Symbol(); // 指定监听全局时候的key\n\n  function Observer(data, fn) {\n    this.data = data;\n    this.proxyCache = new WeakMap(); // 以对象为key 存放该对象对应\n    this.pathCache = new WeakMap(); // 以对象为key 存放该对象所在路径的Map\n    this.watchList = []; // 监听的回调函数队列\n\n    /**\n     * 需要将整体对象作为key，存储为空数组，因为后续的对象路径需要基于父对象\n     * 的路径进行拼接 path.concat(props)，所以需要保证整个对象对应的路径是[]\n     */\n    this.pathCache.set(data, []);\n\n    this.scheduler = new Scheduler(data, ({ newValue, oldValue, paths }) => {\n      // 触发监听的回调\n      // 触发全局监听的回调\n      this.watchList.map((watch) => {\n        if (watch.key === globalKey) {\n          // 全局key的监听\n          watch.fn(newValue, oldValue);\n        } else if (paths.indexOf(watch.key) >= 0){\n          // 根属性的key的监听，并且key需要在paths中，只有更改了的属性才会触发回调\n          watch.fn(newValue[watch.key], oldValue[watch.key]);\n        }\n      });\n    });\n\n    // Proxy的get Handler\n    this.getHandler = function getHandler(target, props, receiver) {\n      /**\n       * TODO: 解决数组调用contact报错的问题，后面再详细看看这个问题\n       */\n      if (typeof props === 'symbol') return target[props]\n\n      const value = Reflect.get(target, props, receiver);\n\n      // 如果为基础类型，则直接返回\n      if (isPrimitiveValue(value)) return value\n      \n      /**\n       * 以该对象为key，然后将这个对象对应的路径存储在pathCache中\n       */\n      const path = this.pathCache.get(target);\n      this.pathCache.set(value, path.concat(props));\n\n      /**\n       * 将该value值作为key值，将该value对应的proxy对象存储起来\n       * \n       * 如果该value对应的proxy存在，则直接返回\n       * 如果该value对应的proxy不存在，则创建一个proxy，然后存储起来，继续返回这个proxy\n       */\n      let proxy = this.proxyCache.get(value);\n\n      if (proxy === undefined) {\n        proxy = new Proxy(value, this.handler);\n        this.proxyCache.set(value, proxy);\n      }\n\n      return proxy\n    };\n\n    this.setHandler = function setHandler(target, props, value, receiver) {\n      const oldValue = Reflect.get(target, props, receiver); // 该属性的老的值\n      const result = Reflect.set(target, props, value);\n\n      // 当前对象的属性，只有是有效属性时，才可以触发修改监听（watch）\n      if (isValidProperty(target, props)) {\n\n        const currentTargetPath = this.pathCache.get(target);\n\n        // 收集同步更新的字段\n        this.scheduler.collect({\n          oldValue,\n          newValue: value,\n          path: currentTargetPath.concat(props)\n        });\n      }\n\n      return result\n    };\n\n    this.handler = {\n      // 保持两个handler里面的this是指向cache的\n      get: (...argv) => this.getHandler(...argv),\n      set: (...argv) => this.setHandler(...argv)\n    };\n\n    /** 监听属性的改变 */\n    this.watch = (rootPath, callback) => {\n      let $rootPath = rootPath;\n      let $callback = callback;\n\n      // 监听全局对象的情况\n      if (typeof rootPath === 'function') {\n        $rootPath = globalKey;\n        $callback = rootPath;\n      }\n\n      this.watchList.push({\n        key: $rootPath,\n        fn: $callback\n      });\n    };\n\n    fn(this.watch);\n\n    return new Proxy(this.data, this.handler)\n  }\n\n  return Observer;\n\n})));\n"]}